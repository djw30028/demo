package com.michaelw.source;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.app.file.FileConsumerProperties;
import org.springframework.cloud.stream.app.file.FileUtils;
import org.springframework.cloud.stream.app.trigger.TriggerConfiguration;
import org.springframework.cloud.stream.app.trigger.TriggerPropertiesMaxMessagesDefaultUnlimited;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Primary;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlowBuilder;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.SourcePollingChannelAdapterSpec;
import org.springframework.integration.dsl.file.FileInboundChannelAdapterSpec;
import org.springframework.integration.dsl.file.Files;
import org.springframework.integration.dsl.support.Consumer;
import org.springframework.integration.scheduling.PollerMetadata;
import org.springframework.util.StringUtils;

import java.io.File;

/**
 * Created by michaelwang on 12/20/16.
 */

@EnableBinding(Source.class)
@Import(TriggerConfiguration.class)
@EnableConfigurationProperties({FileSourceProperties.class, FileConsumerProperties.class, TriggerPropertiesMaxMessagesDefaultUnlimited.class})
public class FileSourceConfiguration {

    @Autowired
    private FileSourceProperties properties;

    @Autowired
    private FileConsumerProperties fileConsumerProperties;

    @Autowired
    @Qualifier("defaultPoller")
    PollerMetadata defaultPoller;

    @Autowired
    Source source;

    //@Primary
    @Bean
    public IntegrationFlow fileSourceFlow() {
        FileInboundChannelAdapterSpec messageSourceSpec = Files.inboundAdapter(new File(this.properties.getDirectory()));

        if (StringUtils.hasText(this.properties.getFilenamePattern())) {
            messageSourceSpec.patternFilter(this.properties.getFilenamePattern());
        } else if (this.properties.getFilenameRegex() != null) {
            messageSourceSpec.regexFilter(this.properties.getFilenameRegex().pattern());
        }

        if (this.properties.isPreventDuplicates()) {
            messageSourceSpec.preventDuplicates();
        }

        IntegrationFlowBuilder flowBuilder = IntegrationFlows
                .from(messageSourceSpec,
                        new Consumer<SourcePollingChannelAdapterSpec>() {

                            @Override
                            public void accept(SourcePollingChannelAdapterSpec sourcePollingChannelAdapterSpec) {
                                sourcePollingChannelAdapterSpec
                                        .poller(defaultPoller);
                            }

                        });
        return FileUtils.enhanceFlowForReadingMode(flowBuilder, this.fileConsumerProperties)
                .channel(source.output())
                .get();
    }

}

=========================
=========================
package com.michaelw.source;

import org.springframework.boot.context.properties.ConfigurationProperties;

import javax.validation.constraints.AssertTrue;
import java.io.File;
import java.util.regex.Pattern;

/**
 * Created by michaelwang on 12/20/16.
 */
@ConfigurationProperties("file")
public class FileSourceProperties {

    private static final String DEFAULT_DIR_XXX = System.getProperty("java.io.tmpdir") +
            File.separator + "dataflow" + File.separator + "input";

    private static final String DEFAULT_DIR = "/usr/local/demo/input";

    /**
     * The directory to poll for new files.
     */
    private String directory = DEFAULT_DIR;

    /**
     * Set to true to include an AcceptOnceFileListFilter which prevents duplicates.
     */
    private boolean preventDuplicates = true;

    /**
     * A simple ant pattern to match files.
     */
    private String filenamePattern;

    /**
     * A regex pattern to match files.
     */
    private Pattern filenameRegex;

    public String getDirectory() {
        return this.directory;
    }

    public void setDirectory(String directory) {
        this.directory = directory;
    }

    public boolean isPreventDuplicates() {
        return this.preventDuplicates;
    }

    public void setPreventDuplicates(boolean preventDuplicates) {
        this.preventDuplicates = preventDuplicates;
    }

    public String getFilenamePattern() {
        return this.filenamePattern;
    }

    public void setFilenamePattern(String filenamePattern) {
        this.filenamePattern = filenamePattern;
    }

    public Pattern getFilenameRegex() {
        return this.filenameRegex;
    }

    public void setFilenameRegex(Pattern filenameRegex) {
        this.filenameRegex = filenameRegex;
    }

    @AssertTrue(message = "filenamePattern and filenameRegex are mutually exclusive")
    public boolean isExclusivePatterns() {
        return !(this.filenamePattern != null && this.filenameRegex != null);
    }

}


http://stackoverflow.com/questions/31297560/spring-integration-dsl-example-of-file-polling-inbound-channel-adapter

@Bean
public IntegrationFlow fileReadingFlow() {
    return IntegrationFlows
            .from(s -> s.file(tmpDir.getRoot()).patternFilter("*.sitest"),
                    e -> e.poller(Pollers.fixedDelay(100)))
            .transform(Transformers.fileToString())
            .channel(MessageChannels.queue("fileReadingResultChannel"))
            .get();
}